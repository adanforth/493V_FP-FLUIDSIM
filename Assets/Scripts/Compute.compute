#pragma kernel render_particles;

#pragma kernel integrate_particles;

#pragma kernel enforce_boundaries;

//#include <UnityShaderVariables.cginc>

struct mesh_data
{
    float4x4 mat;
};

// Particle Information
RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<float3> particleVelocities;
RWStructuredBuffer<mesh_data> meshProperties;
float _r;

// Integration
float _gravity;
float _timeStep;
float _numSubSteps;

// Grid Stuff
RWStructuredBuffer<float3> cellTypes;
StructuredBuffer<float> cellIsSolid;
float _width;
float _height;
float _resX;
float _resY;


// for boundaries
float _minX;
float _maxX;
float _minY;
float _maxY;
float x_cell_width;
float y_cell_width;

// RANDOMIZER

uint WangHash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

// Generate a random float between 0 and 1, given a seed
float RandomFloat(uint seed)
{
    return float(WangHash(seed)) / 4294967295.0;
}

[numthreads(64, 1, 1)]
void render_particles(uint3 id : SV_DispatchThreadID)
{
    float4x4 mat = meshProperties[id.x].mat;

    mat[0][3] = particlePositions[id.x].x;
    mat[1][3] = particlePositions[id.x].y;

    meshProperties[id.x].mat = mat;
}

[numthreads(64, 1, 1)]
void integrate_particles(uint3 id : SV_DispatchThreadID) 
{
    particleVelocities[id.x].y += _timeStep * _gravity;
    particlePositions[id.x].x += particleVelocities[id.x].x * _timeStep;
    particlePositions[id.x].y += particleVelocities[id.x].y * _timeStep;
}

[numthreads(64, 1, 1)]
void enforce_boundaries(uint3 id : SV_DispatchThreadID)
{
    float x = particlePositions[id.x].x;
    float y = particlePositions[id.x].y;
    
    if (x < _minX)
    {
        particlePositions[id.x].x = _minX;
        particleVelocities[id.x].x = 0.0;
    } 
    if (x > _maxX)
    {
        particlePositions[id.x].x = _maxX;
        particleVelocities[id.x].x = 0.0;
    }
    if (y < _minX)
    {
        particlePositions[id.x].y = _minY;
        particleVelocities[id.x].y = 0.0;
    }
    if (y > _maxX)
    {
        particlePositions[id.x].y = _maxY;
        particleVelocities[id.x].y = 0.0;
    }
}

[numthreads(64, 1, 1)]
void reset_cell_types(uint3 id : SV_DispatchThreadID)
{
    // given some point...
    
    // find cell that contains the point...
    
    // find delta x and delta y...
    
    // 
    
}


[numthreads(64, 1, 1)]
void particle_to_grid(uint3 id : SV_DispatchThreadID)
{
    // given some point...
    
    // find cell that contains the point...
    
    // find delta x and delta y...
    
    // 
    
}

[numthreads(64, 1, 1)]
void grid_to_particle(uint3 id : SV_DispatchThreadID)
{
    // for some point...

    // for u component...
    
    // find the cell coords...
    float x_p = particlePositions[id.x].x;
    float y_p = particlePositions[id.x].y;
    
    x_p = clamp(x_p, x_cell_width, _resX * x_cell_width);
    y_p = clamp(y_p, y_cell_width, _resY * y_cell_width);

        
    
    //float x_cell = floor(x_p / _x);
    
    // find delta x and delta y...
    
    // 
  
}



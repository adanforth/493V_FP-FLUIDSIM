#pragma kernel render_particles;

#pragma kernel integrate_particles;

#include <UnityShaderVariables.cginc>

struct mesh_data
{
    float4x4 mat;
};

// Particle Information
RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<float3> particleVelocities;
RWStructuredBuffer<mesh_data> meshProperties;

// Integration
float _gravity;
float _timeStep;
float _numSubSteps;

// Grid Stuff
float _width;
float _height;

// RANDOMIZER

uint WangHash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

// Generate a random float between 0 and 1, given a seed
float RandomFloat(uint seed)
{
    return float(WangHash(seed)) / 4294967295.0;
}

[numthreads(64, 1, 1)]
void render_particles(uint3 id : SV_DispatchThreadID)
{
    float4x4 mat = meshProperties[id.x].mat;
    float3 base_pos = particlePositions[id.x];


    //// Calculate the push amount
    //const float3 dir = normalize(base_pos - pusher_position);
    //const float3 push_amount = dir * lerp(0, 20, t);
    //const float3 new_pos = base_pos + push_amount;
    
    //mat[0][3] = base_pos.x + diff;
    //mat[1][3] = base_pos.y + diff;
    mat[1][3] = base_pos.y;
    ////mat[1][3] = clamp(base_pos.y - rand(base_pos.xy), limits.z, limits.w);
    ////mat[2][3] = new_pos.z;
    ////data[id.x].basePos = float3(mat[0][3], mat[1][3], 0);
    meshProperties[id.x].mat = mat;
}

[numthreads(64, 1, 1)]
void integrate_particles(uint3 id : SV_DispatchThreadID) 
{
    particlePositions[id.x].y += _timeStep * _gravity;
    //particlePositions[id.x].x += particleVelocities[id.x].x * dt;
    //particlePositions[id.x].y += particleVelocities[id.x].y * dt;
}
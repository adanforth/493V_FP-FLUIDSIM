#pragma kernel render_particles;

#pragma kernel integrate_particles;

#pragma kernel enforce_boundaries;

#pragma kernel reset_cell_types;

#pragma kernel reset_cell_velocities_and_weights;

#pragma kernel mark_fluid_cells;

//#include <UnityShaderVariables.cginc>

struct mesh_data
{
    float4x4 mat;
};

// Particle Information
RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<float3> particleVelocities;
RWStructuredBuffer<mesh_data> meshProperties;
float _r;

// Integration
float _gravity;
float _timeStep;
float _numSubSteps;

// Grid Stuff
RWStructuredBuffer<float> cellTypes;
StructuredBuffer<float> cellIsSolid;
RWStructuredBuffer<float3> cellWeights;
RWStructuredBuffer<float3> cellVelocities;
RWStructuredBuffer<float3> prevCellVelocities;
float _width;
float _height;
float _resX;
float _resY;

// cell states
float FLUID_CELL;
float AIR_CELL;
float SOLID_CELL;

// for boundaries
float _minX;
float _maxX;
float _minY;
float _maxY;
float x_cell_width;
float y_cell_width;

// RANDOMIZER

uint WangHash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

// Generate a random float between 0 and 1, given a seed
float RandomFloat(uint seed)
{
    return float(WangHash(seed)) / 4294967295.0;
}

[numthreads(64, 1, 1)]
void render_particles(uint3 id : SV_DispatchThreadID)
{
    float4x4 mat = meshProperties[id.x].mat;

    mat[0][3] = particlePositions[id.x].x - _r;
    mat[1][3] = particlePositions[id.x].y - _r ;

    meshProperties[id.x].mat = mat;
}

[numthreads(64, 1, 1)]
void integrate_particles(uint3 id : SV_DispatchThreadID) 
{
    //particleVelocities[id.x].y += _timeStep * _gravity;
    particleVelocities[id.x].y += _timeStep * 3 * (2 * RandomFloat(id.x) - 1);
    particleVelocities[id.x].x += _timeStep * 3 * (2 * RandomFloat(id.x) - 1);
    particlePositions[id.x].x += particleVelocities[id.x].x * _timeStep;
    particlePositions[id.x].y += particleVelocities[id.x].y * _timeStep;
}

[numthreads(64, 1, 1)]
void enforce_boundaries(uint3 id : SV_DispatchThreadID)
{
    float x = particlePositions[id.x].x;
    float y = particlePositions[id.x].y;
    
    if (x < _minX)
    {
        particlePositions[id.x].x = _minX;
        particleVelocities[id.x].x = 0.0;
    } 
    if (x > _maxX)
    {
        particlePositions[id.x].x = _maxX;
        particleVelocities[id.x].x = 0.0;
    }
    if (y < _minY)
    {
        particlePositions[id.x].y = _minY;
        particleVelocities[id.x].y = 0.0;
    }
    if (y > _maxY)
    {
        particlePositions[id.x].y = _maxY;
        particleVelocities[id.x].y = 0.0;
    }
}

[numthreads(64, 1, 1)]
void reset_cell_types(uint3 id : SV_DispatchThreadID)
{
    cellTypes[id.x] = cellIsSolid[id.x] == 0.0 ? SOLID_CELL : AIR_CELL;
}

[numthreads(64, 1, 1)]
void reset_cell_velocities_and_weights(uint3 id : SV_DispatchThreadID)
{
    cellVelocities[id.x] = float3(0.0, 0.0, 0.0);
    cellWeights[id.x] = float3(0.0, 0.0, 0.0);
}

[numthreads(64, 1, 1)]
void mark_fluid_cells(uint3 id : SV_DispatchThreadID)
{
    int n = _resY + 1;
    float h = _height / _resY;
    float h1 = 1.0 / h;
    float h2 = 0.5 * h;
    
    float x_p = particlePositions[id.x].x;
    float y_p = particlePositions[id.x].y;
    
    int x_i = (int)  clamp(floor(x_p * h1), 0.0, _resX);
    int y_i = (int)  clamp(floor(y_p * h1), 0.0, _resY);

    int cell_nr = (int) x_i * n + y_i;
    if (cellTypes[ cell_nr] == AIR_CELL)
    {
        cellTypes[cell_nr] = FLUID_CELL;
    }
}



[numthreads(64, 1, 1)]
void particle_to_grid(uint3 id : SV_DispatchThreadID)
{
    // given some point...
    // Used for both  u and v
    int n = _resY + 1;
    float h = _height / _resY;
    float h1 = 1.0 / h;
    float h2 = 0.5 * h;
    
    // Set velocities and weights to 0.
    
    
    
    // For the u component...   
    // find cell that contains the point...
    
    
    
    // find delta x and delta y...
    
    // 
}

[numthreads(64, 1, 1)]
void grid_to_particle(uint3 id : SV_DispatchThreadID)
{
    // for some point...

    // for u component...
    //float dx = 
    
    // find the cell coords...
    float x_p = particlePositions[id.x].x;
    float y_p = particlePositions[id.x].y;
    
    x_p = clamp(x_p, x_cell_width, _resX * x_cell_width);
    y_p = clamp(y_p, y_cell_width, _resY * y_cell_width);

        
    
    //float x_cell = floor(x_p / _x);
    
    // find delta x and delta y...
    
    // 
  
}


